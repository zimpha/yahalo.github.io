<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
<meta name="pinterest" content="nopin">
<meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
<meta name="generator" content="Hugo 0.75.0@zimpha" />



<link rel="canonical" href="https://zimpha.github.io/algonotes/zeckendorf-arithmetic/">


    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.5.0/css/font-awesome.min.css" rel="stylesheet">
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/solarized_dark.min.css">
    <title>Zeckendorf Arithmetic - zimpha&#39;s blog</title>
    
<meta name="description" content="&lt;p&gt;本文主要介绍了如何使用斐波那契数列来表示整数，也就是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem&#34;&gt;Zeckendorf representation&lt;/a&gt;，以及如何用 &lt;code&gt;Zeckendorf representation&lt;/code&gt; 做整数的基本运算。&lt;/p&gt;">

<meta property="og:title" content="Zeckendorf Arithmetic - zimpha&#39;s blog">
<meta property="og:type" content="article">
<meta property="og:url" content="https://zimpha.github.io/algonotes/zeckendorf-arithmetic/">
<meta property="og:image" content="https://zimpha.github.io/images/default.png">
<meta property="og:site_name" content="zimpha&#39;s blog">
<meta property="og:description" content="&lt;p&gt;本文主要介绍了如何使用斐波那契数列来表示整数，也就是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem&#34;&gt;Zeckendorf representation&lt;/a&gt;，以及如何用 &lt;code&gt;Zeckendorf representation&lt;/code&gt; 做整数的基本运算。&lt;/p&gt;">
<meta property="og:locale" content="ja_JP">

<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="zimpha&#39;s blog">
<meta name="twitter:url" content="https://zimpha.github.io/algonotes/zeckendorf-arithmetic/">
<meta name="twitter:title" content="Zeckendorf Arithmetic - zimpha&#39;s blog">
<meta name="twitter:description" content="&lt;p&gt;本文主要介绍了如何使用斐波那契数列来表示整数，也就是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem&#34;&gt;Zeckendorf representation&lt;/a&gt;，以及如何用 &lt;code&gt;Zeckendorf representation&lt;/code&gt; 做整数的基本运算。&lt;/p&gt;">
<meta name="twitter:image" content="https://zimpha.github.io/images/default.png">


<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "NewsArticle",
    "mainEntityOfPage": {
      "@type": "WebPage",
      "@id":"https:\/\/zimpha.github.io\/"
    },
    "headline": "Zeckendorf Arithmetic - zimpha\u0027s blog",
    "image": {
      "@type": "ImageObject",
      "url": "https:\/\/zimpha.github.io\/images\/default.png",
      "height": 800,
      "width": 800
    },
    "datePublished": "2020-08-08T16:35:55JST",
    "dateModified": "2020-08-08T16:35:55JST",
    "author": {
      "@type": "Person",
      "name": "zimpha\u0027s blog"
    },
    "publisher": {
      "@type": "Organization",
      "name": "zimpha\u0027s blog",
      "logo": {
        "@type": "ImageObject",
        "url": "https:\/\/zimpha.github.io\/images/logo.png",
        "width": 600,
        "height": 60
      }
    },
    "description": "\u003cp\u003e本文主要介绍了如何使用斐波那契数列来表示整数，也就是 \u003ca href=\u0022https:\/\/en.wikipedia.org\/wiki\/Zeckendorf%27s_theorem\u0022\u003eZeckendorf representation\u003c\/a\u003e，以及如何用 \u003ccode\u003eZeckendorf representation\u003c\/code\u003e 做整数的基本运算。\u003c\/p\u003e"
  }
</script>


    <link href="https://zimpha.github.io/css/styles.css" rel="stylesheet">
    
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$','$$'], ['\\[', '\\]']],
          processEscapes: true,
          processEnvironments: true
        },
        options: {
          skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        }
      };
    
      window.addEventListener('load', (event) => {
          document.querySelectorAll("mjx-container").forEach(function(x){
            x.parentElement.classList += 'has-jax'})
        });
    
    </script>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </head>

  <body>
    
    
    

    <header class="l-header">
      <nav class="navbar navbar-default">
        <div class="container">
          <div class="navbar-header">
            <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
              <span class="sr-only">Toggle navigation</span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
              <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="https://zimpha.github.io/">zimpha&#39;s blog</a>
          </div>

          <div id="navbar" class="collapse navbar-collapse">
            
            <ul class="nav navbar-nav navbar-right">
              
              <li><a href="/about/">About</a></li>
              
            </ul>
            
            <ul class="nav navbar-nav navbar-right">
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Resources <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/algonotes/">Algorithm Notes</a></li>
                  
                  <li><a href="/resource/problems">Problem Settings</a></li>
                  
                  <li><a href="/resource/translation/">Transalation</a></li>
                  
                </ul>
              </li>
              
            </ul>
            
            <ul class="nav navbar-nav navbar-right">
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Tools <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/tools/generator">Generator</a></li>
                  
                  <li><a href="/tools/algorithmic-library">Algorithmic Library</a></li>
                  
                </ul>
              </li>
              
            </ul>
            
            <ul class="nav navbar-nav navbar-right">
              
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">Editorials <span class="caret"></span></a>
                <ul class="dropdown-menu">
                  
                  <li><a href="/editorials/project-euler">Project Euler</a></li>
                  
                  <li><a href="/editorials/opencup">Open Cup</a></li>
                  
                  <li><a href="/editorials/petrozavodsk">Petrozavodsk Training Camp</a></li>
                  
                </ul>
              </li>
              
            </ul>
            
            <ul class="nav navbar-nav navbar-right">
              
              <li><a href="/">Home</a></li>
              
            </ul>
            
          </div>

        </div>
      </nav>
    </header>

    <main>
      <div class="container">
        
<div class="row">
  <div class="col-md-8">

    <nav class="p-crumb">
      <ol class="breadcrumb">
        <li><a href="https://zimpha.github.io/"><i class="fa fa-home" aria-hidden="true"></i></a></li>
        
        <li itemscope="" itemtype="http://data-vocabulary.org/Breadcrumb"><a href="https://zimpha.github.io/algonotes/" itemprop="url"><span itemprop="title">algonotes</span></a></li>
        
        <li class="active">Zeckendorf Arithmetic</li>
      </ol>
    </nav>

    <article class="single">
  <header>
    <h1 class="title">Zeckendorf Arithmetic</h1>
    
    <ul class="p-facts">
        <li><i class="fa fa-calendar" aria-hidden="true"></i><time datetime="2020-08-08T16:35:55JST">2020-08-08</time></li>
        <li>来源: <a href=""></a></li>
        
        

        
      </ul>
  </header>

  

  <div class="article-body"><p>本文主要介绍了如何使用斐波那契数列来表示整数，也就是 <a href="https://en.wikipedia.org/wiki/Zeckendorf%27s_theorem">Zeckendorf representation</a>，以及如何用 <code>Zeckendorf representation</code> 做整数的基本运算。</p>
<h2 id="zeckendorf-representation">Zeckendorf representation</h2>
<p>斐波那契数列的定义如下：</p>
<p><span class="math display">\[F_0 = 0, \quad F_1 = 1, \quad F_i = F_{i-1} + F_{i-2} \ \ \ \text{for}\ \ i \geq 2,
\]</span></p>
<p>任意自然数都可以表示成一些互不相同的斐波那契数之和，比如</p>
<p><span class="math display">\[\begin{aligned}
12 &= 5 + 3 + 2 + 1 + 1 = F_5 + F_4 + F_3 + F_2 + F_1 \\
   &= 8 + 3 + 1 = F_6 + F_4 + F_2
\end{aligned}
\]</span></p>
<p>其中在某个特定条件下，存在一个唯一表示法：不使用连续两个斐波那契数。准确的说，假设 <span class="math inline">\(N\)</span> 是一个正整数，那么存在正整数序列 <span class="math inline">\(c\)</span>，满足 <span class="math inline">\(c_i \ge 2\)</span> 并且 <span class="math inline">\(c_{i+1} > c_i + 1\)</span>，使得</p>
<p><span class="math display">\[N = \sum_{i=0}^{k} F_{c_i}
\]</span></p>
<p>这个就是正整数 <span class="math inline">\(N\)</span> 的 <code>Zeckendorf representation</code>。证明如下，</p>
<p>首先证明存在性，即任意正整数 <span class="math inline">\(n\)</span> 都有一个 <code>Zeckendorf representation</code>。</p>
<p>考虑数学归纳法。对于 <span class="math inline">\(n=1,2,3\)</span>，结论显然是正确的，因为他们都是斐波那契数。对于 <span class="math inline">\(n=4\)</span>，有 <span class="math inline">\(4=3+1\)</span>，显然也是对的。假设所有 <span class="math inline">\(a < n\)</span> 的数都有 <code>Zeckendorf representation</code>，考虑 <span class="math inline">\(n\)</span>。如果 <span class="math inline">\(n\)</span> 是斐波那契数，显然结果是对的。否则，存在一个 <span class="math inline">\(i\)</span>，使得 <span class="math inline">\(F_i < n < F_{i+1}\)</span>。令 <span class="math inline">\(a=n-F_i\)</span>，由于 <span class="math inline">\(a < n\)</span>，显然存在一个 <code>Zeckendorf representation</code>。同时有 <span class="math inline">\(a < F_{i+1} - F_i = F_{i-1}\)</span>，因此 <span class="math inline">\(a\)</span> 的 <code>Zeckendorf representation</code> 里不存在 <span class="math inline">\(F_{i-1}\)</span>。因此，<span class="math inline">\(n\)</span> 可以表示为 <span class="math inline">\(F_i\)</span> 加上 <span class="math inline">\(a\)</span> 的 <code>Zeckendorf representation</code>。</p>
<p>接下来考虑证明唯一性，即不存在一个正整数 <span class="math inline">\(n\)</span> 有两个不同的 <code>Zeckendorf representation</code>。</p>
<p>首先考虑一个斐波那契数集合 <span class="math inline">\(S\)</span>，里面最大数是 <span class="math inline">\(F_i\)</span>，并且任意两个数不构成连续的斐波那契数，那么有<span class="math inline">\(\sum_{x \in S} < F_{i+1}\)</span>。这个可以用数学归纳法证明。</p>
<p>考虑两个这样的集合 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span>，并且它们的和一样。令 <span class="math inline">\(S^\prime\)</span> 和 <span class="math inline">\(T^\prime\)</span> 是 <span class="math inline">\(S\)</span> 和 <span class="math inline">\(T\)</span> 移除了公共元素后的子集，显然 <span class="math inline">\(S^\prime\)</span> 和 <span class="math inline">\(T^\prime\)</span> 的和也是一样的。接下来用反证法证明 <span class="math inline">\(S^\prime\)</span> 和 <span class="math inline">\(T^\prime\)</span> 至少有一个是空集。</p>
<p>假设 <span class="math inline">\(S^\prime\)</span> 和 <span class="math inline">\(T^\prime\)</span> 都是非空的，那么令 <span class="math inline">\(F_s\)</span> 是 <span class="math inline">\(S^\prime\)</span> 里的最大数，<span class="math inline">\(F_t\)</span> 是 <span class="math inline">\(T^\prime\)</span> 里的最大数。显然有 <span class="math inline">\(F_s \ne F_t\)</span>。不妨令 <span class="math inline">\(F_s < F_t\)</span>，那么根据一开始的引理，有 <span class="math inline">\(\sum_{x \in S^\prime} x < F_{s+1}\)</span>。也有 <span class="math inline">\(\sum_{x \in S^\prime} x < F_{t}\)</span>，因为 <span class="math inline">\(s+1 \le t\)</span>。但是 <span class="math inline">\(\sum_{x \in T^\prime}\)</span> 是至少为 <span class="math inline">\(F_t\)</span> 的，出现了矛盾。</p>
<p>于是就可以证明 <span class="math inline">\(S^\prime = T^\prime = \emptyset\)</span>，因此 <span class="math inline">\(S=T\)</span>，也就是说表示是唯一的。</p>
<p>如果我们用 <span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span> 来表示每个斐波那契数取还是不取，那么考虑所有小于 <span class="math inline">\(F_{k+2}\)</span> 的数，我们可以用一个长度为 <span class="math inline">\(n\)</span> 的二进制串 <span class="math inline">\(a_{n-1} \ldots a_1 a_0\)</span> 来表示。如果这个二进制串里没有连续相邻的<span class="math inline">\(1\)</span>，那么它可以唯一表示一个数</p>
<p><span class="math display">\[a_{n-1} \cdot F_{n+1} + \ldots + a_1 \cdot F_3 + a_0 \cdot F_2
\]</span></p>
<p>显然，这样的串总共有 <span class="math inline">\(F_{n+2}\)</span> 个，也就是说我们可以表示从 <span class="math inline">\(0\)</span> 到 <span class="math inline">\(F_{n+2}-1\)</span> 的所有数。</p>
<p>那么给出一个正整数 <span class="math inline">\(n\)</span> 之后，如果得到它的 <code>Zeckendorf representation</code> 呢？可以考虑如下的贪心做法：首先找一个最大的不超过 <span class="math inline">\(n\)</span> 的斐波那契数 <span class="math inline">\(F_{k_1}\)</span>，之后找一个最大的不超过 <span class="math inline">\(n-F_{k_1}\)</span> 的斐波那契数 <span class="math inline">\(F_{k_2}\)</span>，依次类推直到 <span class="math inline">\(n\)</span> 变成 <span class="math inline">\(0\)</span> 为止。可以发现这个就是我们在证明存在性用的方法，因此找出来的一定是一个合法的 <code>Zeckendorf representation</code>。</p>
<h2 id="basic-arithmetic">Basic arithmetic</h2>
<p>下面介绍如何只用 <code>Zeckendorf representation</code> 做整数的基本运算</p>
<h3 id="incrementation">Incrementation</h3>
<p>首先考虑最简单的情况，我们有一个长度为 <span class="math inline">\(n\)</span> 二进制串 <span class="math inline">\(a_{n-1} \ldots a_1 a_{0}\)</span> 表示整数 <span class="math inline">\(x\)</span>，我们想要知道 <span class="math inline">\(x+1\)</span> 的表示 <span class="math inline">\(b_{n}b_{n-1} \dots b_1 b_{0}\)</span>。多了一位 <span class="math inline">\(b_n\)</span> 是因为当 <span class="math inline">\(x=F_{n+2}-1\)</span> 的时候，<span class="math inline">\(x+1=F_{n+2}\)</span>，没法用 <span class="math inline">\(n\)</span> 位二进制串来表示。</p>
<p>仅考虑最后两位 <span class="math inline">\(a_1a_0\)</span>，我们可以发现只有两种情况：如果 <span class="math inline">\(a_0=0\)</span>，我们只需要改成 <span class="math inline">\(a_0=1\)</span> 即可，等价于加上了 <span class="math inline">\(F_2=1\)</span>；否则，最后两位一定是 <span class="math inline">\(01\)</span>，我们可以把它们改成 <span class="math inline">\(10\)</span>，因为 <span class="math inline">\(F_3-F_2=1\)</span>。总结下的话，就是以下三种 <span class="math inline">\(a_1a_0 \to c_1c_0\)</span> 的转换规则</p>
<p><span class="math display">\[00. \to 01. \qquad  01. \to 10. \qquad  10. \to 11.
\]</span></p>
<p>可以发现，在做完上述转化之后，我们得到的二进制串里可能会有相邻的 <span class="math inline">\(1\)</span>。我们需要想办法移除掉这些相邻的 <span class="math inline">\(1\)</span>。注意到 <span class="math inline">\(F_{k+2}=F_{k+1}+F_{k}\)</span>，于是我们可以简单的应用这个规则：<span class="math inline">\(011 \to 100\)</span>。这个肯定不会改变这个串的值。</p>
<p>注意到应用这个规则一次后，可能会产生新的相邻的 <span class="math inline">\(1\)</span>。因此，我们需要从低位开始应用这个规则，这样只会在更高位产生相邻的<span class="math inline">\(1\)</span>。在后续的枚举过程中，会继续被消掉。</p>
<p>至此，我们可以在 <span class="math inline">\(O(n)\)</span> 时间内从 <span class="math inline">\(x\)</span> 变成 <span class="math inline">\(x+1\)</span>。</p>
<h3 id="addition">Addition</h3>
<p>接下来考虑更加复杂点的情况，我们需要把 <span class="math inline">\(a_{n-1} \ldots a_1 a_{0}\)</span> 加到一个斐波那契数 <span class="math inline">\(F_{j+2}\)</span> 上去。如果 <span class="math inline">\(a_j = 0\)</span>，那么我们只需要把 <span class="math inline">\(a_j\)</span> 改成 <span class="math inline">\(1\)</span>。接下来，如果产生了一对相邻的 <span class="math inline">\(1\)</span>，可以应用上文的规则消掉这一对 <span class="math inline">\(1\)</span>。如果产生了三个连续的 <span class="math inline">\(1\)</span>，我们可以先消掉最后两个 <span class="math inline">\(1\)</span>，也就是说 <span class="math inline">\(111 \to 200\)</span>。接下来想办法消掉这个 <span class="math inline">\(2\)</span> 就好了。</p>
<p>可以发现，这个和 <span class="math inline">\(a_j=1\)</span> 是等价的，考虑这个情况即可。可以发现，这个 <span class="math inline">\(2\)</span> 的周围肯定都是 <span class="math inline">\(0\)</span>。因此，当 <span class="math inline">\(j \ge 2\)</span> 的时候，我们可以考虑如下的规则：</p>
<p><span class="math display">\[0200 \to 0111 \to 1001 \qquad  0201 \to 0112 \to 1002
\]</span></p>
<p>对于前者，我们直接把 <span class="math inline">\(2\)</span> 都消掉了。对于后者，<span class="math inline">\(2\)</span> 会往后移动两个位置。这两个规则可以简单的表示成下面的形式，其中 <span class="math inline">\(x \in \{0, 1\}\)</span>，<span class="math inline">\(\bar{x} = x+1\)</span>：</p>
<p><span class="math display">\[020x \to 100\bar{x}
\]</span></p>
<p>最终 <span class="math inline">\(2\)</span> 会移动到最后一位或者倒数第二位，也就是 <span class="math inline">\(j \in \{0, 1\}\)</span>。那么我们就可以用下面两个规则消掉这个 <span class="math inline">\(2\)</span>：</p>
<p><span class="math display">\[020. \to 101. \qquad  02. \to 10.
\]</span></p>
<p>之后得到的串可能还是有相邻的 <span class="math inline">\(1\)</span>，继续应用之前的规则消掉即可。</p>
<p>至此，我们也得到了一个 <span class="math inline">\(O(n)\)</span> 的算法。如果考虑对两个 <span class="math inline">\(n\)</span> 位整数 <span class="math inline">\(a_{n-1} \ldots a_1 a_{0}\)</span> 和 <span class="math inline">\(b_{n-1} \ldots b_1 b_{0}\)</span> 相加的话，就可以对每一个 <span class="math inline">\(b_j=1\)</span> 的 <span class="math inline">\(F_{j+2}\)</span> 应用刚才的 <span class="math inline">\(O(k^2)\)</span> 的做法。这样就有一个 <span class="math inline">\(O(n^2)\)</span> 的算法来做加法。</p>
<p>显然，我们可以有更快的做法。不妨令 <span class="math inline">\(c_j=a_j+b_j\)</span>，那么数字串 <span class="math inline">\(c_{n-1} \ldots c_1 c_0\)</span> 只会有数字 <span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span> 或者 <span class="math inline">\(2\)</span>。我们需要想办法消掉这些 <span class="math inline">\(2\)</span> 和相邻的 <span class="math inline">\(1\)</span>。</p>
<p>首先我们只考虑消掉所有的 <span class="math inline">\(2\)</span>。如果只用 <span class="math inline">\(020x \to 100\bar{x}\)</span> 这个规则，当 <span class="math inline">\(x=2\)</span> 的时候，我们可能引入 <span class="math inline">\(3\)</span>。因此，我们需要加入一些新的规则：</p>
<p><span class="math display">\[030x \to 021\bar{x} \to 110\bar{x}
\]</span></p>
<p>然后，由于相邻 <span class="math inline">\(1\)</span> 的存在，做 <span class="math inline">\(0201 \to 1002\)</span> 变换之后，可能会出现 <span class="math inline">\(2\)</span> 后面跟着一个 <span class="math inline">\(1\)</span> 的情况。类似的，做 <span class="math inline">\(0200 \to 1001\)</span> 变换之后，可能会出现 <span class="math inline">\(1\)</span> 后面跟着一个 <span class="math inline">\(2\)</span> 的情况。我们还需要另外的规则处理它们：</p>
<p><span class="math display">\[021x \to 110x \qquad  012x \to 101x
\]</span></p>
<p>于是，我们现在总共有如下 <span class="math inline">\(4\)</span> 种规则，其中 <span class="math inline">\(x \in \{0, 1, 2\}\)</span>，<span class="math inline">\(\bar{x} = x+1\)</span>：</p>
<p><span class="math display">\[020x \to 100\bar{x} \qquad  030x \to 110\bar{x} \qquad  021x \to 110x \qquad  012x \to 101x
\]</span></p>
<p>我们还需要特殊处理末尾，即 <span class="math inline">\(j \in \{0, 1\}\)</span>的情况。但是，如果我们把 <span class="math inline">\(F_0\)</span> 和 <span class="math inline">\(F_1\)</span> 临时加入 <code>Zeckendorf representation</code> 里，也就是允许 <span class="math inline">\(c_{-1}\)</span> 和 <span class="math inline">\(c_{-2}\)</span> 的出现。那么直接用上面规则就可完全消掉 <span class="math inline">\(2\)</span>，但是可能会出现 <span class="math inline">\(c_{-1}=1\)</span> 或者 <span class="math inline">\(c_{-2} = 1\)</span>。对于后者，我们可以直接忽略，因为 <span class="math inline">\(F_0=0\)</span>。对于前者，我们稍后再处理。</p>
<p>之后，我们就得到了一个只包含 <span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span> 的数字串。接下来，我们应用规则 <span class="math inline">\(011 \to 100\)</span> 两遍。第一遍从高位到低位，第二遍从低位到高位。</p>
<p>可以发现第一遍操作完之后，不存在三个连续的 <span class="math inline">\(1\)</span>，也就是说连续的 <span class="math inline">\(1\)</span> 个数最多是 <span class="math inline">\(2\)</span>。接下来，<span class="math inline">\(c_0\)</span> 和 <span class="math inline">\(c_{-1}\)</span> 不可能同时是 <span class="math inline">\(1\)</span>，于是当 <span class="math inline">\(c_{-1}=1\)</span>的时候，可以直接令 <span class="math inline">\(c_0=1,c_{-1}=0\)</span>。</p>
<p>在这个基础上，第二遍就可以轻松做了。</p>
<p>至此，我们有了一个 <span class="math inline">\(O(n)\)</span> 的算法来实现加法。</p>
<h3 id="subtraction">Subtraction</h3>
<p>接下来考虑如何实现两个 <span class="math inline">\(n\)</span> 位整数 <span class="math inline">\(x=a_{n-1} \ldots a_1 a_{0}\)</span> 和 <span class="math inline">\(y=b_{n-1} \ldots b_1 b_{0}\)</span> 的减法。不妨假设 <span class="math inline">\(x \ge y\)</span>，不然只需要反过来，然后加上负号即可。</p>
<p>减法相对于加法就简单了不少，我们一开始令<span class="math inline">\(c_j=a_j-b_j\)</span>，那么就得到了一个包含 <span class="math inline">\(-1\)</span>，<span class="math inline">\(0\)</span> 或者 <span class="math inline">\(1\)</span> 的数字串。为了简意起见，我们把 <span class="math inline">\(-1\)</span> 写成 <span class="math inline">\(\bar{1}\)</span>。</p>
<p>首先，我们从高位到低位处理每一位，使得最终序列仅包含 <span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span> 或者 <span class="math inline">\(2\)</span>。由于 <span class="math inline">\(x \ge y\)</span>，第一个非 <span class="math inline">\(0\)</span> 位肯定不会是 <span class="math inline">\(\bar{1}\)</span>。先考虑如下的规则：</p>
<p><span class="math display">\[100 \to 011 \qquad 1\bar{1}0 \to 001 \qquad 1\bar{1}1 \to 002 \qquad 10\bar{1} \to 010
\]</span></p>
<p>可以简化成，其中 <span class="math inline">\(x \in \{0, -1\}, y \in \{0, 1\}\)</span>：</p>
<p><span class="math display">\[10x \to 01\bar{x} \qquad 1\bar{1}y \to 00\bar{y}
\]</span></p>
<p>由于我们引入了 <span class="math inline">\(2\)</span>，可能会导致 <span class="math inline">\(2\)</span> 后面跟着 <span class="math inline">\(-1\)</span>，同样需要把这些情况处理掉，因此加入下面的规则：</p>
<p><span class="math display">\[200 \to 111 \qquad 2\bar{1}0 \to 101 \qquad 2\bar{1}1 \to 102 \qquad 20\bar{1} \to 110
\]</span></p>
<p>基本就是把 <span class="math inline">\(2\)</span> 拆成 <span class="math inline">\(111\)</span> 后合并到后续的位上去。</p>
<p>接下来我们就得到了一个仅包含 <span class="math inline">\(0\)</span>，<span class="math inline">\(1\)</span> 或者 <span class="math inline">\(2\)</span> 的序列，可以发现每个 <span class="math inline">\(2\)</span> 要么左右两侧都有一个 <span class="math inline">\(0\)</span>，要么后面跟着一个 <span class="math inline">\(0\)</span>。这个和加法得到的序列性质是一样的，因此可以直接套用加法的做法。</p>
<p>于是，我们也可以 <span class="math inline">\(O(n)\)</span> 时间做好减法了。</p>
<h3 id="complementing">Complementing</h3>
<p>由于减法的出现，那么类似的我们就可以思考如何表示负数呢。在传统的计算机里面，我们是用补码来表示负数的，类似的，我们可以考虑用补码来表示负数。在二进制里面，我们是加上 <span class="math inline">\(2^n\)</span> 来得到补码的，那么在 <code>Zeckendorf representation</code>，可以加上 <span class="math inline">\(F_{n+2}\)</span> 来得到补码。</p>
<p>求补码的过程就是两个 <code>Zeckendorf representation</code> 的整数的减法，直接套用上述算法即可。</p>
<h3 id="canonicalization">Canonicalization</h3>
<p>上面我们讨论了，如果把通过加法和减法得到的串变成一个合法的 <code>Zeckendorf representation</code>。但是我们更常遇到的事一般情况：</p>
<blockquote>
<p>给出<span class="math inline">\(N=\sum\limits_{i=0}^{n} a_i \cdot F_{i}\)</span>，求出它的 <code>Zeckendorf representation</code></p>
<p>其中 <span class="math inline">\(1 \le n \le 10^6, 1 \le a_i \le 10^{18}\)</span></p>
</blockquote>
<p>这个我们称之为正则化 (Canonicalization)。我们可以利用加法的做法来解决这个问题。</p>
<p>令 <span class="math inline">\(A = \sum\limits_{i=0}^{n-1} \lfloor \frac{a_i}{2} \rfloor \cdot F_{i+2}\)</span>，<span class="math inline">\(B = \sum\limits_{i=0}^{n-1} (a_i \bmod 2) \cdot F_{i+2}\)</span>，显然 <span class="math inline">\(N = 2A + B\)</span>。如果我们能够分别求得 <span class="math inline">\(A\)</span> 和 <span class="math inline">\(B\)</span> 的 <code>Zeckendorf representation</code>，那么就可以用两次加法来得到 <span class="math inline">\(N\)</span> 的 <code>Zeckendorf representation</code>。</p>
<p>可以发现，对于 <span class="math inline">\(B\)</span> 的 <code>Zeckendorf representation</code>，直接应用加法的简化规则就可以了。对于 <span class="math inline">\(A\)</span> 的 <code>Zeckendorf representation</code>，我们可以变成一个子问题，递归的做。</p>
<p>因此可以在 <span class="math inline">\(O(n \log A)\)</span> 的时间正则化。</p>
<p>还可以利用一些恒等式来做，比如说 <span class="math inline">\(F_{m}F_{n}+F_{m-1}F_{n-1} = F_{n+m-1}\)</span>。</p>
<p>首先，从低位到高位考虑每个 <span class="math inline">\(a_i\)</span>，显然可以运用规则 <span class="math inline">\(011 \to 100\)</span>，把 <span class="math inline">\(\min(a_i, a_{i-1})\)</span> 加到 <span class="math inline">\(a_{i+1}\)</span> 上去，然后从 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(a_{i-1}\)</span> 上减去 <span class="math inline">\(\min(a_i, a_{i-1})\)</span>。这样一来，我们的 <span class="math inline">\(a\)</span> 序列一定满足而 <span class="math inline">\(a_i \cdot a_{i-1} = 0\)</span>。</p>
<p>接下来考虑从高位到低位依次考虑每个 <span class="math inline">\(a_i\)</span>，显然可以把 <span class="math inline">\(a_i\)</span> 拆成若干个 <span class="math inline">\(F_j\)</span> 的和，那么我们可以考虑利用<span class="math inline">\(F_{i}F_{j}+F_{i-1}F_{j-1} = F_{i+j-1}\)</span>，给答案加上 <span class="math inline">\(F_{i+j-1}\)</span>，同时给 <span class="math inline">\(a_{i-1}\)</span> 加上 <span class="math inline">\(F_{j-1}\)</span>。</p>
<p>对于前者，可以用之前在加法讨论过的做法，不过我们只保证到 <span class="math inline">\(res_i\)</span> 为止。如果应该规则到了比 <span class="math inline">\(i\)</span> 小的位置 <span class="math inline">\(j\)</span>，直接修改 <span class="math inline">\(a_j\)</span> 即可。</p>
<p>可以发现，这样每次加上 <span class="math inline">\(F_{i+j-1}\)</span> 的复杂度也是 <span class="math inline">\(O(\log A)\)</span> 的。</p>
<h3 id="multiplication">Multiplication</h3>
<p>接下来考虑如何实现两个 <span class="math inline">\(n\)</span> 位整数 <span class="math inline">\(x=a_{n-1} \ldots a_1 a_{0}\)</span> 和 <span class="math inline">\(y=b_{n-1} \ldots b_1 b_{0}\)</span> 的乘法。</p>
<p>首先考虑一个复杂点的做法，</p>
<p><span class="math display">\[\forall m \ge n \ge 2, F_mF_n=\sum_{r=1}^{\lfloor \frac{n}{2} \rfloor}F_{m+n+2-4r}+\begin{cases}0 & n \bmod 2 = 0 \\ F_{m-n+1} & n \bmod 2 = 1 \end{cases}
\]</span></p>
<p>其中，如果 <span class="math inline">\(n=m\)</span> 是奇数，那么用 <span class="math inline">\(F_2\)</span> 代替 <span class="math inline">\(F_1\)</span>。</p>
<p>这个意味着什么呢，说明我们可以单独考虑每一位 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_j\)</span>，得到一个没有正则化的 <code>Zeckendorf representation</code>，之后套用正则化的算法就可以了。</p>
<p>令<span class="math inline">\(S_i=S_{i-4}+F_i\)</span>，那么上述公式可以表示为</p>
<p><span class="math display">\[\forall m \ge n \ge 2, F_mF_n=S_{n+m-2}+\begin{cases}F_{m-n+2}-S_{m-n+2} & n \bmod 2 = 0 \\ F_{m-n+4}-S_{m-n+4}+F_{m-n+1} & n \bmod 2 = 1 \end{cases}
\]</span></p>
<p>同样，如果 <span class="math inline">\(n=m\)</span> 是奇数，那么用 <span class="math inline">\(F_2\)</span> 代替 <span class="math inline">\(F_1\)</span>。</p>
<p>很显然，如果我们能够求出每个 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(S\)</span> 前面的系数，那么就可以求出一个没有正则化的 <code>Zeckendorf representation</code>。注意到，这些系数其实可以表示成关于 <span class="math inline">\(a_i\)</span> 和 <span class="math inline">\(b_j\)</span> 的若干个不同的卷积。</p>
<p>于是我们就可以用FFT求出每个 <span class="math inline">\(F\)</span> 和 <span class="math inline">\(S\)</span> 前面的系数。然后稍微处理下就得到了每个 <span class="math inline">\(F\)</span> 前面最终的系数 <span class="math inline">\(c_2,c_3,\dots,c_m\)</span>。最后套用正则化算法就解决了这个问题。</p>
<p>上述方法需要做很多次 FFT，不免有点慢，可以使用 <a href="https://en.wikipedia.org/wiki/Lucas_number">Lucas Number</a> 来优化。</p>
<p>我们知道 <span class="math inline">\(L_n = F_{n-1}+F_{n+1}=F_n+2F_{n-1}=F_{n+2}-F_{n-2}\)</span>，但还有一个重要的公式</p>
<p><span class="math display">\[F_{n+k}+(-1)^{k}F_{n-k}=L_{k}F_{n}
\]</span></p>
<p>其中，我们允许下标为负数，幸亏在下标为负数的时候斐波那契数的所有性质都是有用的，即 <span class="math inline">\(F_{-n}=(-1)^{n-1}F_n\)</span>。</p>
<p>于是我们可以把其中一个 <code>Zeckendorf representation</code> 表示成若干个 Lucas Number 的和。这个直接用一开始提到的式子就可以搞定。</p>
<p>接下来的话，就可以应用 <span class="math inline">\(F_{n+k}+(-1)^{k}F_{n-k}=L_{k}F_{n}\)</span>，我们分别做两个卷积，就可以求出 <span class="math inline">\(F_{n+k}\)</span> 和 <span class="math inline">\(F_{n-k}\)</span> 的系数了。下面的做法都是类似的，正则化一下答案即可。</p>
<p>虽然使用 Lucas Number 之后，仅需要做两次卷积，但是我们还可以更快。考虑使用斐波那契数列通项公式来优化。</p>
<p>我们知道，<span class="math inline">\(F_n=\frac{1}{\sqrt{5}}(\phi^n-(-\phi)^{-n})\)</span>，那么可以把 <span class="math inline">\(\sqrt{5} F_n\)</span> 看成一个多项式 <span class="math inline">\(x^n-(-x)^{-n}\)</span>。因此，两个数 <span class="math inline">\(\sqrt{5} x\)</span> 和 <span class="math inline">\(\sqrt{5} y\)</span>，我们可以分别看成两个多项式 <span class="math inline">\(A(x)\)</span> 和 <span class="math inline">\(B(x)\)</span>。</p>
<p>考虑 <span class="math inline">\(C(x)=A(x)B(x)\)</span>，它是 <span class="math inline">\(5xy\)</span> 对应的多项式，我们把它除以 <span class="math inline">\(\sqrt{5}\)</span> 就得到了 <span class="math inline">\(\sqrt{5} xy\)</span> 对应的多项式。显然这个多项式肯定也是有这种 <span class="math inline">\(x^n-(-x)^{-n}\)</span> 的对称性，我们从高到底就可以恢复出它的 <code>Zeckendorf representation</code>。只有套用正则化的算法即可。</p>
<p>除以 <span class="math inline">\(\sqrt{5}\)</span> 可以利用 <span class="math inline">\(\phi^4=(\phi+1)^2=3\phi+1=\sqrt{5} \phi\)</span> 来做。</p>
<p>上述的做法复杂度都是 <span class="math inline">\(O(n \log n)\)</span> 的。</p>
<h3 id="division">Division</h3>
<p>先考虑一类特殊的减法：求出 <span class="math inline">\(F_{n+k} - F_n\)</span> 的 <code>Zeckendorf representation</code>。</p>
<p>首先，我们有</p>
<p><span class="math display">\[F_{n+k}-F_n = \sum_{r=1}^{\lfloor \frac{k}{2} \rfloor} F_{n+k+1-2r} + \begin{cases} 0 & k \equiv 0 \pmod 2 \\ F_{n-1} & k \equiv 1 \pmod 2 \end{cases}
\]</span></p>
<p>这个可以通过数学归纳法证明，或者暴力应用 <span class="math inline">\(F_{n+2}=F_{n+1}+F_n\)</span> 把 <span class="math inline">\(F_{n+k}\)</span> 拆掉。</p>
<p>根据 <span class="math inline">\(F_{n+k}=F_k F_{n+1} + F_{k-1} F_n\)</span>，如果令 <span class="math inline">\(k=n\)</span> 的话，我们有</p>
<p><span class="math display">\[F_{2n}=F_n F_{n+1} + F_{n-1} F_n
\]</span></p>
<p>因此，<span class="math inline">\(F_{2n}\)</span> 是 <span class="math inline">\(F_n\)</span> 的倍数。类似的，有</p>
<p><span class="math display">\[F_{3n}=F_2n F_{n+1} + F_{2n-1} F_n
\]</span></p>
<p>显然，<span class="math inline">\(F_{3n}\)</span> 也是 <span class="math inline">\(F_n\)</span> 的倍数。依次类推，我们就可以发现 <span class="math inline">\(F_{kn}\)</span> 是 <span class="math inline">\(F_n\)</span> 的倍数。于是就可以考虑这样的问题：求出 <span class="math inline">\(\frac{F_{kn}}{F_n}\)</span> 的 <code>Zeckendorf representation</code>。</p>
<p>考虑 <span class="math inline">\(F_{kn}\)</span> 和 <span class="math inline">\(F_n\)</span> 的通项公式，我们知道</p>
<p><span class="math display">\[\frac{F_{kn}}{F_n} = \frac{\alpha^{kn} - \beta^{kn}}{\alpha^n - \beta^n}=\sum_{i=1}^{k} \alpha^{(k-i)n} \beta^{(i-1)n}
\]</span></p>
<p>由于 <span class="math inline">\(\alpha \beta = -1\)</span>，我们可以得到，对于 <span class="math inline">\(1 \le r \le \lfloor \frac{k}{2} \rfloor\)</span></p>
<p><span class="math display">\[\alpha^{(k-r)n} \beta^{(r-1)n}+\alpha^{(r-1)n} \beta^{(k-r)n}=(-1)^{(r-1)n}(\alpha^{(k-2r+1)n}+\beta^{(k-2r+1)n})=(-1)^{(r-1)n} L_{(k-2r+1)n}
\]</span></p>
<p>于是，根据 <span class="math inline">\(k\)</span> 的奇偶性，我们可以得到</p>
<p><span class="math display">\[\frac{F_{kn}}{F_n}=\sum_{r=1}^{\lfloor \frac{k}{2} \rfloor} (-1)^{(r-1)n} L_{(k-2r+1)n} + \begin{cases} (-1)^{\frac{(k-1)n}{2}} & k \equiv 1 \pmod 2 \\ 0 & k \equiv 0 \pmod 2 \end{cases}
\]</span></p>
<p>对于偶数的 <span class="math inline">\(n\)</span>，我们可以直接用 <span class="math inline">\(L_n=L_{n+1}+L_{n-1}\)</span> 来替换。对于 <span class="math inline">\(n\)</span> 是奇数，替换需要复杂得很多，这里先略去。</p>
<p>对于更加通用的除法，目前没有什么好的方法。只能先转成别的进制，做完除法后再转回 <code>Zeckendorf representation</code>。</p>
<h2 id="binary-representation">Binary representation</h2>
<p>接下来介绍如何从 <code>Zeckendorf representation</code> 转成 <code>binary representation</code>。由于 <code>binary representation</code> 可以转成任意其他进制，因此我们也就可以做到从 <code>Zeckendorf representation</code> 转成任意进制。</p>
<h3 id="conversion-to-zeckendorf-representation">Conversion to Zeckendorf representation</h3>
<p>需要利用 Lucas Number 来辅助，我们知道</p>
<p><span class="math display">\[L_m=F_{m+1}+F_{m-1}=\phi_{+}^{m}+\phi_{-}^m
\]</span></p>
<p>其中，<span class="math inline">\(\phi_{\pm} = \frac{1 \pm \sqrt{5}}{2}\)</span>。并且对于任意的 <span class="math inline">\(m\)</span> 和 <span class="math inline">\(k\)</span> 都有</p>
<p><span class="math display">\[F_{n+k}+(-1)^{k}F_{n-k}=L_{k}F_{n}
\]</span></p>
<p>给出一个长度为 <span class="math inline">\(2n\)</span> 的二进制数 <span class="math inline">\(A\)</span>，令 <span class="math inline">\(L_m \ge 2^{n+1} > L_{m-1}\)</span>。考虑把 <span class="math inline">\(A\)</span> 除以 <span class="math inline">\(L_m\)</span></p>
<p><span class="math display">\[A = A_1 L_m + A_0
\]</span></p>
<p>假设我们搞出了 <span class="math inline">\(A_1\)</span> 和 <span class="math inline">\(A_0\)</span> 的 <code>Zeckendorf representation</code>，那么就可以利用 <span class="math inline">\(L_k F_n\)</span> 的恒等式求出 <span class="math inline">\(A_1 L_m\)</span> 的 <code>Zeckendorf representation</code>，之后套用一个加法算法即可。</p>
<p>可以发现 <span class="math inline">\(A_1\)</span> 和 <span class="math inline">\(A_0\)</span> 分别有 <span class="math inline">\(n-1\)</span> 和 <span class="math inline">\(n+1\)</span> 位，整数除法的复杂度是 <span class="math inline">\(O(n  \log n)\)</span> 的，那么有</p>
<p><span class="math display">\[T(2n) \le T(n+2)+T(n-1) + O(n \log n)
\]</span></p>
<p>因此整体复杂度是 <span class="math inline">\(O(n \log^2 n)\)</span> 的。</p>
<h3 id="conversion-to-binary-representation">Conversion to binary representation</h3>
<p>这个是上述问题的逆问题，我们可以考虑将上述算法反着用。找到一个 <span class="math inline">\(m\)</span> 使得差不多能够把  <code>Zeckendorf representation</code> 分成等长的两部分。然后考虑如下的式子</p>
<p><span class="math display">\[A=A_1 L_m + B, \qquad B=A_1^\prime-A^{\prime \prime}+A_0
\]</span></p>
<p>其中 <span class="math inline">\(A_1^\prime\)</span> 和 <span class="math inline">\(A^{\prime \prime}\)</span> 是根据 <span class="math inline">\(L_m F_k\)</span> 关系化简出来的。</p>
<p>利用减法和加法的算法构建出 <span class="math inline">\(B\)</span> 的 <code>Zeckendorf representation</code>，然后分别递归求 <span class="math inline">\(A_1\)</span> 和 <span class="math inline">\(B\)</span> 的二进制表示即可。</p>
<p>最后通过整除乘法把 <span class="math inline">\(A_1\)</span>，<span class="math inline">\(L_m\)</span> 和 <span class="math inline">\(B\)</span> 的结构合并起来。</p>
<p>可以发现，复杂度也是 <span class="math inline">\(O(n \log^2 n)\)</span> 的。</p>
<h2 id="dynamic-zeckendorf-representation">Dynamic Zeckendorf representation</h2>
<p>上面说了很多东西，那么一个数的 <code>Zeckendorf representation</code> 是不是可以动态维护呢，也就是下面这个问题：</p>
<blockquote>
<p>你开始有个数 <span class="math inline">\(X=0\)</span>，然后有 <span class="math inline">\(Q\)</span> 个操作，每次 <span class="math inline">\(X = X + a \cdot F_b\)</span> 或者 <span class="math inline">\(X = X - a \cdot F_b\)</span>。每次操作完需要维护处理一些关于 <span class="math inline">\(X\)</span> 的 <code>Zeckendorf representation</code> 相关的询问。</p>
<p><span class="math inline">\(1 \le Q \le 10^5, 1 \le a, b \le 10^{9}\)</span></p>
</blockquote>
<p>还是利用 Lucas number 和斐波那契数数之间的恒等式：</p>
<p><span class="math display">\[L_k \cdot F_n = F_{n+k} + (-1)^kF_{n-k}
\]</span></p>
<p>如果我们把<span class="math inline">\(a\)</span>拆成若干个 Lucas number 的和，就可以用上面的式子变成加上或者减去若干个斐波那契数，这就比较方便维护了。</p>
<p>经过一些观察发现，加入或者减去一个 <span class="math inline">\(F_x\)</span> 的话，只和 <span class="math inline">\(X\)</span> 的 <code>Zenkorf representation</code> 中那些极大的 <code>10101...10101</code> 有关，因此可以用一个 Treap 来维护这些极大的 <code>10101..101</code> 段。考虑加法的话，有以下几种情况：</p>
<ol>
<li><span class="math inline">\(F_{x-1},F_{x}, F_{x+1}\)</span> 都不存在，那么直接加上一个 <span class="math inline">\(F_x\)</span> 即可。</li>
<li><span class="math inline">\(F_{x-1},F_{x}, F_{x+1}\)</span> 至少有一个存在，那么假设包含 <span class="math inline">\(x\)</span> 的 <code>101..101</code> 段中最高位 <span class="math inline">\(1\)</span> 和最低位 <span class="math inline">\(1\)</span> 分别是 <span class="math inline">\(l\)</span> 和 <span class="math inline">\(r\)</span>，还可以分成下面几种情况：
<ul>
<li><span class="math inline">\(x=r+1\)</span>，那么需要把 <span class="math inline">\(F_r\)</span> 删掉，加入 <span class="math inline">\(F_{r+2}\)</span>。</li>
<li><span class="math inline">\(l \le x \le r\)</span> 并且 <span class="math inline">\(x \equiv l \bmod 2\)</span>，那么需要把 <span class="math inline">\(F_{l}, F_{l+2}, \dots, F_{r}\)</span> 都删掉，加入 <span class="math inline">\(F_{r+1}\)</span>, <span class="math inline">\(F_{l+1},F_{l+3}, \dots, F_{x-1}\)</span> 和 <span class="math inline">\(F_{l-2}\)</span>。</li>
<li><span class="math inline">\(l \le x \le r\)</span> 并且 <span class="math inline">\(x \not \equiv l \bmod 2\)</span>，那么需要把 <span class="math inline">\(F_{x+1},F_{x+3},\dots,F_r\)</span> 都删掉，加入 <span class="math inline">\(F_{r+1}\)</span>。</li>
</ul>
</li>
</ol>
<p>注意到在加入 <span class="math inline">\(F_{r+2}\)</span> 或者 <span class="math inline">\(F_{l-2}\)</span> 的时候可能会出现两个相邻的 <code>1</code>，需要递归重复以上过程。显然，递归有限次后就会结束。</p>
<p>考虑减法的话，也是类似的分析后可以搞定。因此可以 <span class="math inline">\(O(\log A)\)</span> 时间维护一次加入或者删除后的 <code>Zenkorf representation</code>，其中 <span class="math inline">\(A = \max(a, b)\)</span>。</p>
<p>整体可以在 <span class="math inline">\(O(Q \log^2 A)\)</span> 的时间搞定这个题。</p>
<h2 id="exercises">Exercises</h2>
<h3 id="coci-20102011-contest-4-hrpahttpstrainnzoiorgnzproblems329"><a href="https://train.nzoi.org.nz/problems/329">COCI 2010/2011. Contest #4. Hrpa</a></h3>
<p>题意：有 <span class="math inline">\(N\)</span> 个石子，两个人玩游戏。第一轮先手可以取任意个石子。接下来，每一轮至少需要取 <span class="math inline">\(1\)</span> 个，但是不能超过之前的两倍。拿走最后一个石子的获胜。</p>
<p>求出先手最少需要拿多少石子才能获胜。</p>
<p><span class="math inline">\(2 \le N \le 10^{15}\)</span></p>
<p>题解：参考<a href="/coci/2010-2011#hrpa">这里</a></p>
<h3 id="xix-oi-round-2-day-2-rozkład-fibonacciegohttpsszkopuleduplproblemsetproblemw1qbhpufazp-sh6x-u4ptnnusitekeystatement"><a href="https://szkopul.edu.pl/problemset/problem/w1QbhPufazp-sH6X-u4pTnNu/site/?key=statement">XIX OI. Round 2. Day 2. Rozkład Fibonacciego</a></h3>
<p>题意：给出一个整数 <span class="math inline">\(N\)</span>，可以用斐波那契数加加减减得到，求出最小需要的项数。</p>
<p><span class="math inline">\(1 \le N \le 4 \times 10^{17}\)</span></p>
<p>题解：参考<a href="/polish-olympiad-in-informatics/2011-2012#day-2">这里</a></p>
<h3 id="ceoi-2018-day-2-fibonacci-representationshttpslojacproblem3185"><a href="https://loj.ac/problem/3185">CEOI 2018 Day 2. Fibonacci Representations</a></h3>
<p>题意：对一个正整数 <span class="math inline">\(p\)</span>，令 <span class="math inline">\(X(p)\)</span> 表示把 <span class="math inline">\(p\)</span> 表示为若干个不同的斐波那契数的和的表示法数，两种表示法不同当且仅当有一个斐波那契数是其中一个的项，而不是另一个的项。</p>
<p>给出 <span class="math inline">\(n\)</span> 个整数 <span class="math inline">\(a_1,a_2,\dots,a_n\)</span>，定义 <span class="math inline">\(p_k=F_{a_1}+F_{a_2}+\dots+F_{a_k}\)</span>。</p>
<p>对于 <span class="math inline">\(k=1,2,\dots,n\)</span>，求出 <span class="math inline">\(X(p_k) \bmod (10^9+7)\)</span>。</p>
<p><span class="math inline">\(1 \le n \le 10^5, 1 \le a_i \le 10^9\)</span></p>
<p>题解：把 <span class="math inline">\(p\)</span> 的 <code>Zeckendorf representation</code> 写出来后，考虑两个连续 <code>1</code> 的位置是 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span>，那么他们的方案数是 <span class="math inline">\(\lfloor \frac{y-x}{2} \rfloor\)</span>。因此，用上面动态维护 <code>Zeckendorf representation</code> 的方法，顺便维护每个 <code>1</code> 拆或者不拆的方案数即可。</p>
<h3 id="pa-2019-round-3-iloczyny-fibonacciegohttpsszkopuleduplproblemsetproblemfdlfc1tbgkoqqzwrttpcrtbcsite"><a href="https://szkopul.edu.pl/problemset/problem/fDlfC1tbgkoQqZwRttPCrtbC/site/">PA 2019. Round 3. Iloczyny Fibonacciego</a></h3>
<p>题意：给出两个整数 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 的 <code>Zeckendorf representation</code>，长度为 <span class="math inline">\(n\)</span> 和 <span class="math inline">\(m\)</span>。求出它们的乘积的 <code>Zeckendorf representation</code>。</p>
<p><span class="math inline">\(1 \le n, m \le 10^6\)</span></p>
<p>题解：就是裸的乘法，参考上面的算法即可。</p>
<h3 id="ontak-2019-day-1-fibonacci-divisionhttpssio2mimuweduplcwiekuisty_ontak2019pfib"><a href="https://sio2.mimuw.edu.pl/c/wiekuisty_ontak2019/p/fib/">ONTAK 2019. Day 1. Fibonacci Division</a></h3>
<p>题意：给出一个数 <span class="math inline">\(x\)</span> 的 <code>Zeckendorf representation</code>，<span class="math inline">\(b_0,b_1,\dots,b_{n-1}\)</span> 和一个整数 <span class="math inline">\(k\)</span>。求出 <span class="math inline">\(\lfloor \frac{x}{k} \rfloor\)</span> 的 <code>Zeckendorf representation</code>。</p>
<p><span class="math inline">\(1 \le n \le 10^5, 1 \le k \le 3\)</span></p>
<p>题解：如果<span class="math inline">\(k=1\)</span>，直接输出输入的数即可。对于 <span class="math inline">\(k=2,3\)</span>，我们可以找出 <span class="math inline">\(\lfloor \frac{F_i}{k} \rfloor\)</span> 的表示，以及 <span class="math inline">\(F_i \bmod k\)</span> 的值。对于前者，我们可以先搞出一个没有正则化的表示，然后做一次正则化即可。对于后者，和不超过 <span class="math inline">\(n \cdot (k-1)\)</span>，直接拆成 <code>Zeckendorf representation</code>，然后和前面的结果做加法即可。</p>
<h2 id="references">References</h2>
<ul>
<li><a href="http://www.algonotes.com/en/fibonacci-arithmetic">Algorithms for arithmetic in Fibonacci and golden ratio representations</a></li>
<li><a href="https://www.cs.auckland.ac.nz/~peter-f/FTPfiles/Zeckendorf.pdf">Zeckendorf Integer Arithmetic</a></li>
<li><a href="https://www.irif.fr/~cf/publications/AUFP.pdf">Efficient Algorithms For Zeckendorf Arithmetic</a></li>
<li><a href="https://www.csie.ntu.edu.tw/~r97002/temp/Concrete%20Mathematics%202e.pdf">Concrete Mathematics</a></li>
<li><a href="https://arxiv.org/pdf/1501.04924.pdf">Zeckendorf arithmetic for Lucas numbers</a></li>
<li><a href="https://doi.org/10.1134/S0032946018040038">On the Complexity of Fibonacci Coding</a></li>
</ul></div>

  <footer class="article-footer">
    
    
    
    
  </footer>

</article>

    
    <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "zimpha" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    
    
    
  </div>

  <div class="col-md-4">
    
<aside class="l-sidebar">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://zimpha.github.io/">
      <button type="submit" class="submit icon-search glyphicon glyphicon-search"></button>
</form>
    </section>
    <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LATESTS</div>
    </div>
    <div class="list-group">
      
      <a href="https://zimpha.github.io/resource/translation/xxvii-poi/" class="list-group-item">XXVII POI Chinese Translation</a>
      
      <a href="https://zimpha.github.io/resource/translation/" class="list-group-item">Translation</a>
      
      <a href="https://zimpha.github.io/editorials/petrozavodsk/2015-winter/jagiellonian-u-contest/" class="list-group-item">Petrozavodsk Winter 2015. Day 6. Jagiellonian U Contest</a>
      
      <a href="https://zimpha.github.io/editorials/petrozavodsk/2015-summer/moscow-ipt-contest/" class="list-group-item">Petrozavodsk Summer 2015. Day 4. Moscow IPT Contest</a>
      
      <a href="https://zimpha.github.io/editorials/project-euler/001/" class="list-group-item">Problem 1. Multiples of 3 and 5</a>
      
    </div>
  </section>

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">TAG</div>
    </div>
    <div class="list-group">
      
      
      <a href="https://zimpha.github.io/tags/inclusion-exclusion-principle" class="taglink">inclusion-exclusion-principle</a>
      
      
      
      <a href="https://zimpha.github.io/tags/math" class="taglink">math</a>
      
      
    </div>
  </section>
  

  
  <section class="panel panel-default">
    <div class="panel-heading">
      <div class="panel-title">LINKS</div>
    </div>
    <ol class="list-group">
      
      <a href="http://www.cnblogs.com/clrs97/" class="list-group-item">Claris</a>
      
      <a href="http://min-25.hatenablog.com/" class="list-group-item">Min_25</a>
      
      <a href="https://blog.csdn.net/skywalkert/" class="list-group-item">skywalkert</a>
      
    </ol>
  </section>
  

</aside>


  </div>
</div>

      </div>
    </main>

    <footer class="l-footer">
      <div class="container">
        <p><span class="h-logo">&copy; zimpha&#39;s blog</span></p>
        <aside>
          <p>Powered by <a href="https://gohugo.io/">Hugo</a>.</p>
          <p><a href="https://github.com/dim0627/hugo_theme_beg">Beg</a> designed by <a href="http://yet.unresolved.xyz/">Daisuke Tsuji</a>.</p>
        </aside>
      </div>
    </footer>

    <script src="//code.jquery.com/jquery-3.1.1.min.js"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </body>
</html>

